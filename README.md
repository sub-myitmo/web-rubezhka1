# web-rubezhka1

<details>
<summary><h4>
<ol>
<li>DHTML и AJAX - основные принципы, сходства и различияDHTML и AJAX - основные принципы, сходства и различия</li>
<li>Основные проблемы, возникающие при параллельной обработке JSP и способы их решения</li>
<li>JS-функция ???</li>
</ol>
</h4></summary>
<ul>

<li>
DHTML (Dynamic HTML) и AJAX (Asynchronous JavaScript and XML) являются двумя технологиями, используемыми для создания интерактивных веб-приложений. Они имеют сходства, но также отличаются друг от друга.

Основные принципы DHTML:

1. Использование HTML, CSS и JavaScript для создания динамических и интерактивных веб-страниц.
2. Обновление содержимого страницы без перезагрузки всей страницы.
3. Использование DOM (Document Object Model) для манипулирования элементами на странице.

Основные принципы AJAX:

1. Асинхронная передача данных между клиентом и сервером без перезагрузки всей страницы.
2. Использование XMLHttpRequest объекта для отправки запросов к серверу без необходимости обновления всей страницы.
3. Обработка полученных данных с помощью JavaScript.

Сходства между DHTML и AJAX:

1. Обе технологии используют JavaScript для создания интерактивности на веб-страницах.
2. Они позволяют обновлять содержимое страницы без полной перезагрузки.

Различия между DHTML и AJAX:

1. DHTML фокусируется на изменении содержимого страницы, в то время как AJAX фокусируется на асинхронной передаче данных между клиентом и сервером.
2. AJAX требует использования XMLHttpRequest объекта, в то время как DHTML не требует этого компонента.
3. DHTML может быть использован для создания сложных пользовательских интерфейсов, тогда как AJAX часто используется для загрузки данных из базы данных или других ресурсов без полной перезагрузки страницы.

</li>

<li>
Одной из основных проблем при параллельной обработке JSP является конкуренция за доступ к ресурсам, таким как база данных, файловая система и другие внешние сервисы. Это может привести к блокировкам и задержкам в обработке запросов.

Для решения этой проблемы можно использовать механизмы синхронизации, такие как блокировки или семафоры, чтобы предотвратить одновременный доступ к ресурсам. Также можно использовать асинхронные запросы для выполнения длительных операций без блокировки основного потока обработки.

Еще одной проблемой является управление состоянием при параллельной обработке. Использование глобальных переменных или состояния на стороне сервера может вызвать неопределенное поведение при параллельном доступе.

Для управления состоянием можно использовать механизмы сессий или контекстов приложений для изоляции данных каждого пользователя или запроса. Также можно использовать иммутабельные объекты и функциональное программирование для создания безопасных структур данных.

Кроме того, возникают проблемы с производительностью при параллельной обработке JSP из-за высокой нагрузки на сервер и ограниченных ресурсов.

Для улучшения производительности можно использовать кэширование результатов вычислений, распределение нагрузки между несколькими серверами или оптимизацию кода и запросов к базе данных. Также можно использовать асинхронную обработку запросов для уменьшения времени ожидания ответа от сервера.

</li>

<li>

</li>

</ul>
</details>




<details>
<summary><h4>
<ol>
<li>Основы HTTP запроса</li>
<li>Promise в JavaScript</li>
<li>Написать сервлет, который пренапраляет любой запрос на страницу http://yandex.ru</li>
</ol>
</h4></summary>
<ul>

<li>
HTTP (Hypertext Transfer Protocol) - это протокол передачи данных, который используется для обмена информацией в Интернете. HTTP запросы отправляются клиентом (например, браузером) к серверу для запроса определенной информации или выполнения определенного действия.

Основные элементы HTTP запроса включают:

1. Метод: Это указывает на тип операции, которую нужно выполнить. Например, GET для получения ресурса, POST для отправки данных на сервер, PUT для обновления существующего ресурса и т.д.

2. URL (Uniform Resource Locator): Это адрес ресурса на сервере, к которому нужно обратиться.

3. Заголовки: Они содержат метаданные о запросе, такие как тип содержимого, язык и т.д.

4. Тело запроса: Опциональная часть запроса, которая содержит данные или параметры для передачи на сервер.

Пример HTTP запроса:
```
GET /index.html HTTP/1.1
Host: www.example.com
User-Agent: Mozilla/5.0
Accept-Language: en-US
```

В этом примере "GET" - это метод запроса, "/index.html" - это URL ресурса на сервере и "Host", "User-Agent", "Accept-Language" - это заголовки запросов.
</li>

<li>
Promise в JavaScript - это объект, который используется для выполнения асинхронных операций и управления их результатами. Он представляет собой обещание о том, что определенная операция будет завершена в будущем, либо успешно (resolve), либо неудачно (reject).

Promise имеет три состояния: 
1. Pending (ожидание) - начальное состояние, когда обещание еще не было выполнено или отклонено.
2. Fulfilled (выполнено) - когда обещание успешно выполнено.
3. Rejected (отклонено) - когда обещание не удалось выполнить.

С помощью Promise можно создавать цепочки асинхронных операций, которые выполняются последовательно друг за другом или параллельно. Это позволяет управлять потоком данных и делать код более читаемым и поддерживаемым.

Пример использования Promise:
```
let promise = new Promise((resolve, reject) => {
  setTimeout(() => {
    let success = true;
    if(success){
      resolve("Operation successful");
    } else {
      reject("Operation failed");
    }
  }, 2000);
});

promise.then((message) => {
  console.log(message);
}).catch((error) => {
  console.error(error);
});
```
В этом примере создается новый Promise объект с задержкой в две секунды. Если операция завершается успешно, то вызывается метод resolve с сообщением "Operation successful", если нет - метод reject с сообщением "Operation failed". Затем мы используем метод then для обработки успешного выполнения и метод catch для отлавливания ошибок.

Promise является мощным инструментом для работы с асинхронными операциями в JavaScript и широко используется в различных библиотеках и фреймворках.
</li>

<li>
Для написания сервлета, который будет перенаправлять любой запрос на страницу http://yandex.ru, вам нужно использовать метод sendRedirect из класса HttpServletResponse. Вот пример кода на Java для сервлета:

```
@WebServlet("/redirect")
public class RedirectServlet extends HttpServlet {
    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        String redirectUrl = "http://yandex.ru";
        response.sendRedirect(redirectUrl);
    }

    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        doGet(request, response);
    }
}
```

В этом примере:

1. @WebServlet("/redirect") указывает на путь, по которому сервлет будет доступен.
2. doGet метод перенаправляет запросы GET на страницу http://yandex.ru с помощью sendRedirect.
3. doPost метод перенаправляет запросы POST также на страницу http://yandex.ru, используя тот же код, что и для GET.

После развертывания этого сервлета на вашем сервере Java EE, все запросы по адресу /redirect будут автоматически перенаправляться на http://yandex.ru.
</li>

</ul>
</details>



<details>
<summary><h4>
<ol>
<li>HTTP коды состояния. Их назначения, пояснения. 7 примеров кодов состояний с их пояснением</li>
<li>JSP Expression language. Что это такое. Назначение, зачем он нужен, если есть JSP-елементы</li>
<li>Правило css для поворота изображения с заданным Id=“simpleForm” на 270 градусов по часовой стрелке</li>
</ol>
</h4></summary>
<ul>

<li>

1. 200 OK - запрос успешно выполнен, сервер возвращает запрошенные данные.
2. 301 Moved Permanently - запрашиваемый ресурс был перемещен на постоянной основе на новый URL.
3. 400 Bad Request - сервер не может обработать запрос из-за некорректного синтаксиса или другой ошибки клиента.
4. 403 Forbidden - доступ к запрашиваемому ресурсу запрещен, сервер отказывает в доступе.
5. 404 Not Found - запрашиваемый ресурс не найден на сервере.
6. 500 Internal Server Error - произошла ошибка на стороне сервера, которая препятствует выполнению запроса.
7. 503 Service Unavailable - сервер временно не может обрабатывать запросы из-за перегрузки или технических проблем.
8. Код состояния 504 HTTP обозначает ошибку "Gateway Timeout". Эта ошибка возникает, когда сервер, действуя в качестве шлюза или прокси-сервера, не может получить ответ вовремя от другого сервера. При возникновении этой ошибки, клиентский запрос не может быть завершен из-за превышения времени ожидания. Например, если сервер, на который делается запрос, не отвечает в течение определенного времени, то может быть сгенерирован код состояния 504.

HTTP коды состояния используются для передачи информации о результате выполнения HTTP-запросов между клиентом и сервером. Коды состояния помогают определить успешность или ошибочность выполнения запросов и действий, которые должны быть предприняты в ответ на эти результаты (например, перенаправление пользователя или вывод сообщения об ошибке).

</li>

<li>

JSP (JavaServer Pages) Expression Language (EL) — это язык, который используется в JSP для упрощения доступа к данным и их манипуляции. Он был введён для упрощения работы с JavaBeans, коллекциями и другими объектами, которые могут быть доступны в контексте JSP.

▎Основные назначения и преимущества EL:

1. Упрощение синтаксиса: EL позволяет обращаться к атрибутам объектов и коллекциям без необходимости использовать сложные Java-выражения. Это делает код более читаемым и поддерживаемым.

2. Изоляция представления от логики: EL помогает отделить логику приложения от представления, что соответствует принципам MVC (Model-View-Controller). Это позволяет разработчикам сосредоточиться на создании пользовательского интерфейса, не углубляясь в детали реализации бизнес-логики.

3. Безопасность: EL автоматически экранирует выводимые данные, что помогает предотвратить уязвимости, такие как XSS (межсайтовый скриптинг).

4. Доступ к различным объектам: EL может использоваться для доступа к различным объектам, таким как JavaBeans, атрибуты сессии, запроса и контекста.

▎Примеры использования EL:

1. Обращение к атрибутам JavaBeans:
   ```
   <jsp:useBean id="user" class="com.example.User" />
   <p>Имя пользователя: ${user.name}</p>
   ```

2. Работа с коллекциями:
   ```
   <c:forEach var="item" items="${itemsList}">
       <p>${item}</p>
   </c:forEach>
   ```

3. Условные выражения:
   ```
   <c:if test="${not empty user}">
       <p>Добро пожаловать, ${user.name}!</p>
   </c:if>
   ```

▎Сравнение с JSP-элементами:

Хотя JSP-элементы (такие как скриптлеты, директивы и теги) предоставляют мощные инструменты для работы с данными, они могут сделать код менее читаемым и сложным для понимания. Например, использование скриптлетов требует написания Java-кода внутри JSP, что может привести к смешению логики и представления.

EL, с другой стороны, предлагает более декларативный подход, позволяя разработчикам использовать простые выражения для доступа к данным. Это делает код более чистым и понятным, а также упрощает его поддержку.


</li>

<li>

```
#simpleForm {
    transform: rotate(270deg);
}
```
</li>

</ul>
</details>




<details>
<summary><h4>
<ol>
<li>Принципы асинхронного исполнения JS. Концептуальные отличия от параллельных программ (например, на языке Java)</li>
<li>Диспетчеризация запросов в веб-приложениях на Java. Интерфейс Request Dispatcher</li>
<li>CSS - правило, устанавливающее красный цвет всем посещенным ссылкам , кроме тех, которые находятся в элементах с классом students</li>
</ol>
</h4></summary>
<ul>

<li>

Асинхронное исполнение в JavaScript и параллельные программы, такие как на языке Java, имеют разные концептуальные подходы к обработке задач. Давайте разберем основные принципы асинхронного исполнения JS и его отличия от параллельного программирования.

▎Асинхронное исполнение в JavaScript

1. Однопоточная модель: JavaScript работает в однопоточном режиме, что означает, что он выполняет код последовательно, по одной операции за раз. Это позволяет избежать проблем с состоянием гонки, которые могут возникать в многопоточных средах.

2. Событийный цикл (Event Loop): JavaScript использует событийный цикл для управления асинхронными операциями. Когда выполняется асинхронный код (например, запросы к серверу, таймеры), он не блокирует основной поток. Вместо этого, когда операция завершена, результат помещается в очередь событий, и основной поток продолжает выполнение других задач.

3. Обещания (Promises): Для работы с асинхронным кодом используются объекты Promise, которые представляют собой результат асинхронной операции. Это позволяет более удобно обрабатывать успех или ошибку выполнения.

4. Async/Await: С введением async и await синтаксис стал более понятным и похожим на синхронный код, что облегчает чтение и поддержку.

▎Параллельное программирование в Java

1. Многопоточность: Java поддерживает многопоточность, что позволяет выполнять несколько потоков одновременно. Каждый поток может выполнять свою задачу независимо от других.

2. Параллелизм: В Java можно создавать несколько потоков, которые могут работать параллельно на многоядерных процессорах, что позволяет значительно увеличить производительность для задач, требующих больших вычислительных ресурсов.

3. Синхронизация: В многопоточных приложениях необходимо учитывать проблемы синхронизации (например, состояние гонки, блокировки), чтобы избежать конфликтов при доступе к общим ресурсам.

4. Использование потоков и ExecutorService: Java предоставляет механизмы, такие как Thread, Runnable и ExecutorService, для управления потоками и их выполнением.

▎Концептуальные отличия

1. Модель исполнения:

   • JavaScript: Однопоточная модель с асинхронным исполнением через событийный цикл.

   • Java: Многопоточная модель с возможностью параллельного выполнения.

2. Управление задачами:

   • JavaScript: Задачи добавляются в очередь событий и обрабатываются по мере их завершения.

   • Java: Задачи могут выполняться одновременно в разных потоках, что требует управления состоянием и синхронизации.

3. Сложность:

   • JavaScript: Более простой подход к асинхронности без необходимости управлять потоками.

   • Java: Более сложная модель, требующая учета многопоточности и синхронизации.

4. Подход к производительности:

   • JavaScript: Оптимизирован для обработки I/O операций (например, сетевых запросов) без блокировки основного потока.

   • Java: Может использовать параллелизм для вычислительно интенсивных задач.
</li>

<li>

Диспетчеризация запросов — это важный аспект разработки веб-приложений на Java, особенно в контексте использования сервлетов и JavaServer Pages (JSP). В этом контексте интерфейс RequestDispatcher играет ключевую роль.

▎Интерфейс RequestDispatcher

RequestDispatcher — это интерфейс, предоставляемый Java EE (Jakarta EE), который позволяет перенаправлять запросы и ответы между сервлетами, JSP и другими ресурсами. Он предоставляет методы для передачи управления от одного компонента к другому в рамках одного запроса.

▎Основные методы интерфейса

1. forward(ServletRequest request, ServletResponse response):

   • Этот метод используется для передачи управления от одного сервлета или JSP к другому ресурсу (например, к другому сервлету или JSP).

   • При использовании forward запрос и ответ остаются в одном контексте, что позволяет передавать атрибуты и параметры.

   • Пример:
    ```
    RequestDispatcher dispatcher = request.getRequestDispatcher("destination.jsp");
    dispatcher.forward(request, response);
    ```
     

2. include(ServletRequest request, ServletResponse response):

   • Этот метод включает содержимое другого ресурса (сервлета или JSP) в текущий ответ.

   • Это позволяет динамически добавлять контент из других ресурсов, не прерывая выполнение текущего сервлета.

   • Пример:
   ```
    RequestDispatcher dispatcher = request.getRequestDispatcher("header.jsp");
          
     dispatcher.include(request, response);
     ```
     

▎Применение RequestDispatcher

1. Перенаправление запросов: Когда необходимо обработать запрос в другом компоненте приложения (например, передать данные от одного сервлета к другому).

2. Инклюзия ресурсов: Когда нужно динамически вставить содержимое одного ресурса в другой, например, при создании шаблонов страниц.

3. Передача атрибутов: RequestDispatcher позволяет передавать атрибуты между ресурсами через объект ServletRequest, что полезно для обмена данными.

▎Пример использования

Вот простой пример использования RequestDispatcher в сервлете:
```
@WebServlet("/example")
public class ExampleServlet extends HttpServlet {
    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        // Установка атрибута
        request.setAttribute("message", "Hello from ExampleServlet!");

        // Получение RequestDispatcher для перенаправления на другой ресурс
        RequestDispatcher dispatcher = request.getRequestDispatcher("/destination.jsp");

        // Перенаправление запроса
        dispatcher.forward(request, response);
    }
}
```

А в destination.jsp вы можете получить доступ к переданному атрибуту:
```
<% String message = (String) request.getAttribute("message"); %>
<p><%= message %></p>
```

</li>

<li>

```
a:visited {
    color: red; /* Устанавливаем красный цвет для всех посещенных ссылок */
}

.students a:visited {
    color: inherit; /* Сбрасываем цвет для посещенных ссылок внутри элементов с классом students */
}
```

</li>

</ul>
</details>


<details>
<summary><h4>
<ol>
<li>HTTP protocol</li>
<li>Jsp основы все 😂 ???</li>
<li>Сервлет калькулятор для 4 базовые операции</li>
</ol>
</h4></summary>
<ul>

<li>

HTTP (Hypertext Transfer Protocol) — это протокол прикладного уровня, который используется для передачи данных в интернете. Он является основой для обмена информацией между клиентами (обычно веб-браузерами) и серверами. Вот основные аспекты HTTP:

▎Основные характеристики HTTP:

1. Запросы и ответы:

   • HTTP-запрос: Клиент отправляет запрос к серверу, чтобы получить ресурсы (например, HTML-страницы, изображения и т. д.). Запрос включает метод (GET, POST, PUT, DELETE и другие), URL, заголовки и иногда тело запроса.

   • HTTP-ответ: Сервер отвечает на запрос клиента, отправляя статус-код (например, 200 OK, 404 Not Found), заголовки и тело ответа (например, HTML-код).

2. Методы HTTP:

   • GET: Запрашивает данные с сервера.

   • POST: Отправляет данные на сервер, например, при заполнении форм.

   • PUT: Обновляет существующий ресурс на сервере.

   • DELETE: Удаляет указанный ресурс с сервера.

3. Статусы ответа:

   • 2xx: Успешные запросы (например, 200 OK).

   • 3xx: Перенаправления (например, 301 Moved Permanently).

   • 4xx: Ошибки клиента (например, 404 Not Found).

   • 5xx: Ошибки сервера (например, 500 Internal Server Error).

4. Безопасность:

   • HTTP передает данные в открытом виде. Для безопасной передачи данных используется HTTPS (HTTP Secure), который шифрует данные с помощью TLS/SSL.

5. Статeless Protocol:

   • HTTP является безсостоянием, что означает, что каждый запрос является независимым и не сохраняет состояние между запросами. Для управления состоянием используются технологии, такие как cookies и сессии.

6. Заголовки:

   • HTTP-заголовки передаются как часть запроса и ответа и содержат метаданные о передаваемых данных (например, тип контента, длину содержимого и т. д.).
</li>

<li>

</li>

<li>

```
@WebServlet("/calculator")
public class CalculatorServlet extends HttpServlet {
    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        // Получаем параметры из запроса
        double num1 = Double.parseDouble(request.getParameter("num1"));
        double num2 = Double.parseDouble(request.getParameter("num2"));
        String operation = request.getParameter("operation");
        double result = 0;

        // Выполняем операцию в зависимости от выбранного действия
        switch (operation) {
            case "add":
                result = num1 + num2;
                break;
            case "subtract":
                result = num1 - num2;
                break;
            case "multiply":
                result = num1 * num2;
                break;
            case "divide":
                if (num2 != 0) {
                    result = num1 / num2;
                } else {
                    response.sendError(HttpServletResponse.SC_BAD_REQUEST, "Division by zero is not allowed.");
                    return;
                }
                break;
            default:
                response.sendError(HttpServletResponse.SC_BAD_REQUEST, "Invalid operation.");
                return;
        }

        // Формируем ответ
        response.setContentType("text/html");
        PrintWriter out = response.getWriter();
        out.println("<html><body>");
        out.println("<h1>Result: " + result + "</h1>");
        out.println("<a href='index.html'>Back</a>");
        out.println("</body></html>");
    }

    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        // Переадресация на метод doPost
        doPost(request, response);
    }
}
```
</li>

</ul>
</details>

<details>
<summary><h4>
<ol>
<li>DOM и BOM</li>
<li>Управление сессиями. HttpSession</li>
<li>Написать на js функцию, которая блокирует ввод во все текстовые поля всех символов, кроме цифр и латинских букв.</li>
</ol>
</h4></summary>
<ul>

<li>

DOM (Document Object Model) и BOM (Browser Object Model) — это два ключевых концепта в веб-разработке, которые помогают взаимодействовать с документами HTML и управлять браузером.

▎DOM (Document Object Model)

DOM — это программный интерфейс для HTML и XML документов. Он представляет структуру документа в виде дерева, где каждый элемент, атрибут и текст являются объектами. С помощью DOM можно:

• Изменять структуру документа: добавлять, удалять или изменять элементы.

• Манипулировать стилями: изменять CSS-стили элементов.

• Обрабатывать события: добавлять обработчики событий для взаимодействия с пользователем.

Пример работы с DOM на JavaScript:
```
// Получить элемент по ID
let element = document.getElementById("myElement");

// Изменить текст элемента
element.textContent = "Новый текст";

// Добавить новый элемент
let newElement = document.createElement("div");
newElement.textContent = "Я новый элемент!";
document.body.appendChild(newElement);
```

▎BOM (Browser Object Model)

BOM — это набор объектов, предоставляемых браузером, который позволяет взаимодействовать с самим браузером. В отличие от DOM, который работает с документом, BOM предоставляет доступ к функциональности браузера. Основные возможности BOM включают:

• Управление окнами: открытие, закрытие и изменение размеров окон.

• Работа с URL: получение информации о текущем URL и изменение его.

• Навигация: управление историей браузера (например, history.back()).

Пример работы с BOM на JavaScript:
```
// Открыть новое окно
let newWindow = window.open("https://www.example.com", "_blank");

// Получить текущий URL
let currentUrl = window.location.href;

// Вернуться на предыдущую страницу
window.history.back();
```

▎Основные отличия

1. Область применения:

   • DOM: работает с содержимым веб-страницы.

   • BOM: работает с самим браузером и его функциональностью.

2. Структура:

   • DOM: представляется в виде дерева объектов.

   • BOM: представляет собой набор объектов и методов, специфичных для браузера.

3. Методы и свойства:

   • DOM: методы для манипуляции элементами (например, getElementById, appendChild).

   • BOM: методы для управления окнами и навигацией (например, window.open, history.pushState).
</li>

<li>
  
Управление сессиями в веб-приложениях — это важный аспект, который позволяет сохранять состояние между запросами от клиента. В Java EE (или Jakarta EE) для этого часто используется интерфейс HttpSession.

▎Что такое HttpSession?
HttpSession — это объект, который используется для хранения данных о пользователе на сервере в течение его сессии. Сессия начинается, когда пользователь впервые обращается к веб-приложению, и заканчивается, когда она истекает или пользователь выходит из системы.

▎Основные функции HttpSession
1. Хранение данных: Вы можете сохранять данные, связанные с пользователем, в объекте сессии. Эти данные доступны на протяжении всей сессии.
2. Идентификация пользователя: Каждая сессия имеет уникальный идентификатор (session ID), который отправляется клиенту в виде cookie или параметра URL.
3. Управление временем жизни: Вы можете установить время жизни сессии, после которого она будет автоматически завершена.

▎Примеры работы с HttpSession

▎Создание и использование сессии
```
public class MyServlet extends HttpServlet {
    protected void doGet(HttpServletRequest request, HttpServletResponse response) {
        // Получить сессию (или создать новую, если она не существует)
        HttpSession session = request.getSession();

        // Сохранить данные в сессии
        session.setAttribute("username", "JohnDoe");

        // Получить данные из сессии
        String username = (String) session.getAttribute("username");

        // Удалить данные из сессии
        session.removeAttribute("username");
    }
}
```

▎Установка времени жизни сессии
```
// Установить время жизни сессии в 30 минут
session.setMaxInactiveInterval(30 * 60); // время в секундах
```

▎Завершение сессии
```
// Завершить сессию
session.invalidate();
```

▎Управление сессиями

1. Сохранение данных: Используйте setAttribute для сохранения данных и getAttribute для их извлечения.
  
2. Удаление данных: Используйте removeAttribute для удаления конкретного атрибута из сессии.

3. Завершение сессии: Метод invalidate() завершает сессию и удаляет все связанные с ней данные.

4. Безопасность: Обратите внимание на безопасность сессий, используя HTTPS и другие меры защиты от атак, таких как XSS и CSRF.

</li>

<li>

```
function restrictInput(event) {
    const regex = /^[a-zA-Z0-9]*$/; // Регулярное выражение для разрешенных символов

    // Получаем значение текущего текстового поля
    const inputValue = event.target.value;

    // Проверяем, соответствует ли значение регулярному выражению
    if (!regex.test(inputValue)) {
        // Если не соответствует, удаляем последний введенный символ
        event.target.value = inputValue.slice(0, -1);
    }
}

// Применяем функцию ко всем текстовым полям при загрузке страницы
window.onload = function() {
    const inputs = document.querySelectorAll('input[type="text"]');
    inputs.forEach(input => {
        input.addEventListener('input', restrictInput);
    });
};
```

</li>

</ul>
</details>


<details>
<summary><h4>
<ol>
<li></li>
<li>CGI - запросы, общение с веб-сервером, плюсы и минусы</li>
<li>Написать получение для сервлета из HTTP имени пользователя</li>
</ol>
</h4></summary>
<ul>

<li>

</li>

<li>

CGI (Common Gateway Interface) — это стандартный протокол, который позволяет веб-серверам взаимодействовать с внешними программами, такими как скрипты и приложения. Эти программы могут обрабатывать запросы от пользователей и возвращать динамически сгенерированные страницы.

▎Как работают CGI-запросы:

1. Запрос от клиента: Пользователь отправляет HTTP-запрос на веб-сервер.

2. Обработка запроса: Если запрашиваемый ресурс является CGI-скриптом, сервер запускает этот скрипт.

3. Передача данных: Сервер передает данные запроса (например, параметры формы) в качестве переменных окружения в CGI-программу.

4. Генерация ответа: CGI-программа обрабатывает запрос и генерирует HTML-код или другой контент.

5. Ответ клиенту: Сервер отправляет сгенерированный ответ обратно клиенту.

▎Плюсы CGI:

1. Язык независимости: CGI-скрипты могут быть написаны на различных языках (Perl, Python, Ruby, C и т.д.).

2. Простота использования: Легко реализовать простые динамические страницы.

3. Стандартизация: CGI является стандартом, поддерживаемым большинством веб-серверов.

▎Минусы CGI:

1. Производительность: Каждый запрос к CGI-скрипту создает новый процесс, что может привести к значительным затратам ресурсов и времени на запуск.

2. Сложность масштабирования: При увеличении нагрузки сервер может столкнуться с проблемами производительности из-за большого количества создаваемых процессов.

3. Безопасность: Неправильно написанные CGI-скрипты могут быть уязвимы для атак, таких как инъекции и утечки данных.

4. Отсутствие состояния: CGI не сохраняет состояние между запросами, что затрудняет разработку сложных приложений.

</li>

<li>

```
@WebServlet("/login")
public class LoginServlet extends HttpServlet {
    protected void doPost(HttpServletRequest request, HttpServletResponse response) 
            throws ServletException, IOException {
        
        // Получение имени пользователя из параметров запроса
        String username = request.getParameter("username");
        
        // Проверка на null и вывод имени пользователя
        if (username != null && !username.isEmpty()) {
            response.setContentType("text/html");
            response.getWriter().println("<h1>Добро пожаловать, " + username + "!</h1>");
        } else {
            response.setContentType("text/html");
            response.getWriter().println("<h1>Имя пользователя не указано!</h1>");
        }
    }
}
```

```
<form action="/login" method="post">
    <label for="username">Имя пользователя:</label>
    <input type="text" id="username" name="username" required>
    <button type="submit">Войти</button>
</form>
```
</li>

</ul>
</details>




<details>
<summary><h4>
<ol>
<li>Структура HTML</li>
<li>Servlet vs FCGI and CGI. Servlet features.</li>
<li>CSS-правило: при наведении курсора на блок класса articles у элемента появляется граница в 2px красного цвета</li>
</ol>
</h4></summary>
<ul>

<li>

▎Объяснение структуры:

1. ```<!DOCTYPE html>:``` Объявляет тип документа и версию HTML (HTML5).

2. ```<html lang="ru">:``` Корневой элемент документа, указывающий язык (в данном случае русский).

3. ```<head>```: Содержит метаданные о документе, такие как:

   • ```<meta charset="UTF-8">```: Устанавливает кодировку символов.

   • ```<meta name="viewport" content="width=device-width, initial-scale=1.0">```: Обеспечивает адаптивность на мобильных устройствах.

   • ```<title>```: Заголовок страницы, отображаемый в вкладке браузера.

   • ```<link>```: Подключение внешнего CSS-файла.

   • ```<script>```: Подключение внешнего JavaScript-файла.

4. ```<body>```: Основное содержимое страницы, включая:

   • ```<header>```: Содержит заголовок и навигацию.

   • ```<main>```: Основной контент страницы, разбитый на разделы (```<section>```).

   • ```<footer>```: Нижний колонтитул с дополнительной информацией.

</li>

<li>

▎CGI (Common Gateway Interface)

CGI — это стандартный интерфейс для взаимодействия веб-сервера с программами, которые генерируют динамический контент. Основные характеристики:

• Производительность: Каждый запрос создает новый процесс, что может привести к значительным накладным расходам.

• Языковая независимость: CGI может быть написан на любом языке программирования, поддерживающем стандартный ввод/вывод (например, Perl, Python, C).

• Состояние: Не поддерживает состояние между запросами (например, сессии).

• Безопасность: Может быть уязвим для различных атак, если не реализован должным образом.

▎FCGI (FastCGI)

FCGI — это улучшенная версия CGI, которая решает некоторые его недостатки:

• Производительность: В отличие от CGI, FCGI использует постоянные процессы для обработки запросов, что значительно уменьшает накладные расходы на создание и уничтожение процессов.

• Поддержка нескольких языков: Как и CGI, может использоваться с различными языками программирования.

• Состояние: FCGI также не поддерживает состояние между запросами, но может быть использован в сочетании с другими технологиями для управления состоянием.

• Масштабируемость: Лучше подходит для высоконагруженных приложений благодаря возможности обработки нескольких запросов одновременно.

▎Servlets

Servlets — это Java-технология для создания динамических веб-приложений. Основные характеристики:

1. Производительность:

   • Servlets работают в контейнере сервлетов (например, Apache Tomcat), который управляет их жизненным циклом и многопоточностью. Это позволяет обрабатывать несколько запросов одновременно без создания новых процессов.

2. Состояние:

   • Servlets могут управлять состоянием с помощью сессий, что позволяет хранить информацию о пользователе между запросами.

3. Интеграция с Java EE:

   • Servlets являются частью Java EE и могут легко интегрироваться с другими компонентами, такими как JSP (JavaServer Pages), EJB (Enterprise JavaBeans) и JPA (Java Persistence API).

4. Безопасность:

   • Поддерживают различные механизмы безопасности, такие как аутентификация и авторизация.

5. Удобство разработки:

   • Java предоставляет мощные средства разработки и отладки, а также множество библиотек для работы с базами данных, сетями и другими ресурсами.

6. Портируемость:

   • Servlets могут работать на любом сервере приложений, поддерживающем спецификацию Java EE.

▎Сравнение

| Характеристика    | CGI                      | FCGI                     | Servlets                 |
|--------------------|-------------------------|--------------------------|--------------------------|
| Производительность  | Низкая                  | Высокая                  | Очень высокая            |
| Создание процессов  | Каждый запрос создает новый процесс | Использует постоянные процессы | Работает в многопоточном контейнере |
| Поддержка состояния | Нет                     | Нет                      | Да                       |
| Языковая зависимость| Любой язык              | Любой язык               | Java                     |
| Интеграция         | Ограниченная            | Ограниченная             | Хорошая (Java EE)       |

</li>

<li>

```
.articles {
    transition: border 0.3s ease;
}

.articles:hover {
    border: 2px solid red; 
}

```
</li>

</ul>
</details>


<details>
<summary><h4>
<ol>
<li>CSS источники, правила, приоритеты</li>
<li>MVC из чего состоит, пример использования</li>
<li>Функция на js которая закроет окно</li>
</ol>
</h4></summary>
<ul>

<li>

В CSS есть несколько источников стилей, правил и принципов приоритета, которые определяют, какие стили применяются к элементам. Вот основные моменты:

▎1. Источники стилей

CSS может быть применен к элементам из различных источников:

• Встроенные стили (Inline styles): Стили, заданные непосредственно в атрибуте style HTML-элемента. Они имеют самый высокий приоритет.
  ```
    <div style="color: red;">Текст</div>
  ```

• Внутренние стили (Internal styles): Стили, определенные внутри тега ```<style>``` в ```<head>``` HTML-документа.
  ```
<style>
    div { color: blue; }
</style>
  ```

• Внешние стили (External styles): Стили, загружаемые из внешнего CSS-файла с помощью тега <link>.
  ```
    <link rel="stylesheet" href="styles.css">
  ```

▎2. Правила CSS

Правила CSS состоят из селекторов и деклараций:

```
p {
    color: green;
}
```

▎3. Приоритеты (Специфичность)

Приоритет стилей определяется специфичностью селекторов. Чем выше специфичность, тем выше приоритет:

• Inline стили: всегда имеют наивысший приоритет.

• ID-селекторы: имеют более высокий приоритет, чем классы и теги.
  ```
    #myId { color: orange; }
  ```

• Классы, атрибуты и псевдоклассы: имеют более высокий приоритет, чем теги.
  ```
    .myClass { color: purple; }
  ```

• Теговые селекторы: имеют наименьший приоритет.
  ```
    div { color: black; }
  ```

▎4. Каскадирование

Если два или более правила применяются к одному элементу и имеют одинаковую специфичность, применяется последнее правило в коде (каскадирование).

▎5. Важность (!important)

Вы можете использовать !important, чтобы переопределить другие правила, но это следует делать с осторожностью:
```
p {
    color: blue !important; /* Этот цвет будет применяться вне зависимости от других правил */
}
```
</li>

<li>
  
MVC (Model-View-Controller) — это архитектурный паттерн, который разделяет приложение на три основные компоненты:

1. Model (Модель): управляет данными и бизнес-логикой приложения.

2. View (Представление): отвечает за отображение данных пользователю.

3. Controller (Контроллер): обрабатывает пользовательский ввод и взаимодействует с моделью и представлением.

▎Пример использования MVC с Java Servlets

Давайте рассмотрим простой пример веб-приложения для управления задачами (To-Do List) с использованием Java Servlets.

▎1. Модель (Model)

Создадим класс Task, который будет представлять задачу.
```
// Task.java
public class Task {
    private String title;
    private boolean completed;

    public Task(String title) {
        this.title = title;
        this.completed = false;
    }

    public String getTitle() {
        return title;
    }

    public boolean isCompleted() {
        return completed;
    }

    public void complete() {
        this.completed = true;
    }
}
```

▎2. Контроллер (Controller)

Создадим сервлет TaskServlet, который будет обрабатывать запросы.
```
@WebServlet("/tasks")
public class TaskServlet extends HttpServlet {
    private List<Task> tasks = new ArrayList<>();

    @Override
    protected void doGet(HttpServletRequest request, HttpServletResponse response)
            throws ServletException, IOException {
        request.setAttribute("tasks", tasks);
        request.getRequestDispatcher("/tasks.jsp").forward(request, response);
    }

    @Override
    protected void doPost(HttpServletRequest request, HttpServletResponse response)
            throws ServletException, IOException {
        String title = request.getParameter("title");
        if (title != null && !title.trim().isEmpty()) {
            tasks.add(new Task(title));
        }
        response.sendRedirect("tasks"); // Перенаправление на GET-запрос для отображения задач
    }
}
```

▎3. Представление (View)

Создадим JSP-страницу tasks.jsp, которая будет отображать список задач.
```
<!-- tasks.jsp -->
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<!DOCTYPE html>
<html>
<head>
    <title>Task List</title>
</head>
<body>
<h1>My Tasks</h1>
<ul>
    <c:forEach var="task" items="${tasks}">
        <li>
            <span>${task.title}</span>
            <span>${task.completed ? ' (Completed)' : ''}</span>
        </li>
    </c:forEach>
</ul>
<form action="tasks" method="post">
    <input type="text" name="title" placeholder="New task" required />
    <button type="submit">Add Task</button>
</form>
</body>
</html>
```

• Модель (Task) представляет задачи и управляет их состоянием.
• Контроллер (TaskServlet) обрабатывает запросы на получение и добавление задач, взаимодействует с моделью и обновляет представление.
• Представление (tasks.jsp) отвечает за отображение задач пользователю и предоставляет интерфейс для добавления новых задач.
</li>

<li>

• Если окно было открыто пользователем (например, через прямой ввод URL), то ```window.close()``` не сработает.
• Для тестирования функции можно открыть новое окно через JavaScript и затем закрыть его. Например:
```
let newWindow = window.open("https://example.com", "_blank");
newWindow.close(); 
```

</li>

</ul>
</details>


<details>
<summary><h4>
<ol>
<li>Отличие fcgi от cgi преимущества и недостатки</li>
<li>Сравнение fetch api с XMLHttpRequest и super Agent</li>
<li>Написать jsp которая будет выводить ошибку и стек ошибки если не отправлен identificator</li>
</ol>
</h4></summary>
<ul>

<li>

FCGI (FastCGI) и CGI (Common Gateway Interface) — это протоколы, используемые для взаимодействия веб-серверов с программами, которые обрабатывают динамический контент. Вот основные отличия, преимущества и недостатки каждого из них:

▎CGI (Common Gateway Interface)

Отличия:

• CGI запускает отдельный процесс для каждого запроса.

• Каждый раз, когда приходит новый запрос, создается новый экземпляр программы.

Преимущества:

• Простота: легко реализовать и использовать.

• Поддержка множества языков программирования.

Недостатки:

• Высокие накладные расходы: запуск нового процесса для каждого запроса занимает много времени и ресурсов.

• Ограниченная производительность при высокой нагрузке.

• Память и ресурсы системы могут быстро исчерпаться при большом количестве одновременных запросов.

▎FCGI (FastCGI)

Отличия:

• FCGI поддерживает постоянные процессы, что позволяет обрабатывать несколько запросов в одном процессе.

• Процессы FCGI остаются активными между запросами, что значительно снижает накладные расходы.

Преимущества:

• Высокая производительность: значительно меньше времени на создание процессов, так как они уже запущены.

• Эффективное использование ресурсов: один процесс может обрабатывать множество запросов.

• Поддержка асинхронной обработки запросов.

Недостатки:

• Более сложная настройка по сравнению с CGI.

• Может потребоваться больше памяти для поддержания активных процессов.

• Не все веб-серверы поддерживают FCGI, хотя большинство популярных серверов это делают.

</li>


<li>

Сравнение Fetch API, XMLHttpRequest и SuperAgent может помочь понять, какой из этих инструментов лучше подходит для работы с HTTP-запросами в JavaScript. Вот основные отличия, преимущества и недостатки каждого из них:

▎1. Fetch API

Описание:
Fetch API — это современный интерфейс для работы с HTTP-запросами, который предоставляет более простой и мощный способ выполнения запросов по сравнению с XMLHttpRequest.

Преимущества:

• Простота использования: Синтаксис основан на промисах, что делает код более читаемым и упрощает обработку асинхронных операций.

• Поддержка Promise: Легко работать с асинхронными запросами и использовать async/await.

• Более гибкие возможности: Поддерживает такие функции, как CORS, Stream API, обработка ответов в различных форматах (JSON, текст и т.д.).

• Чистота кода: Меньше кода для выполнения тех же операций.

Недостатки:

• Не поддерживает IE: Не работает в Internet Explorer без полифиллов.

• Обработка ошибок: Ошибки сети обрабатываются, но ошибки HTTP (например, 404 или 500) не вызывают отклонение промиса.

▎2. XMLHttpRequest

Описание:
XMLHttpRequest (XHR) — это старый интерфейс для выполнения HTTP-запросов в браузерах.

Преимущества:

• Широкая поддержка: Работает во всех браузерах, включая старые версии.

• Синхронные и асинхронные запросы: Можно выполнять запросы как синхронно, так и асинхронно (хотя синхронные запросы не рекомендуются).

Недостатки:

• Сложный синтаксис: Код может быть громоздким и трудным для чтения из-за коллбэков.

• Отсутствие поддержки Promise: Не поддерживает нативно промисы, что усложняет работу с асинхронными операциями.

• Устаревший подход: Сложнее управлять потоками данных и обработкой ответов.

▎3. SuperAgent

Описание:
SuperAgent — это библиотека для выполнения HTTP-запросов, которая предоставляет удобный интерфейс для работы с AJAX-запросами.

Преимущества:

• Удобный синтаксис: Использует цепочки методов для создания запросов, что делает код более читабельным.

• Поддержка Promise: Работает с промисами и поддерживает async/await.

• Расширенные возможности: Легко добавлять обработчики для различных типов ответов и ошибок.

• Поддержка браузеров: Работает во всех современных браузерах.

Недостатки:

• Дополнительная зависимость: Необходима установка библиотеки, что увеличивает размер проекта.

• Не так широко распространен, как Fetch API: Меньшее количество примеров и документации по сравнению с Fetch.

▎Заключение

• Fetch API является предпочтительным выбором для новых проектов благодаря своей простоте и современному подходу к работе с асинхронными запросами.

• XMLHttpRequest все еще может использоваться в старых проектах или когда требуется поддержка устаревших браузеров.

• SuperAgent — хороший выбор, если вам нужны дополнительные возможности и удобный интерфейс, но стоит учитывать необходимость подключения внешней библиотеки.

</li>

<li>

```
<%
    // Получаем параметр identificator
    String identificator = request.getParameter("identificator");

    // Проверяем наличие параметра
    if (identificator == null || identificator.isEmpty()) {
        // Если параметр отсутствует, выводим сообщение об ошибке
        out.println("<h1>Ошибка: Параметр 'identificator' не отправлен!</h1>");
        
        // Выводим стек ошибки
        Exception e = new Exception("Отсутствует параметр 'identificator'");
        e.printStackTrace(new PrintWriter(out));
    } else {
        // Если параметр присутствует, можно обработать его
        out.println("<h1>Параметр 'identificator': " + identificator + "</h1>");
    }
%>
```
</li>

</ul>
</details>


остальное:
1. https://invited-digit-866.notion.site/2022-53c853d396364002b29a1331dfc78bba#80cee9d88a03495ea134ec05a365d43c
2. https://docs.google.com/document/d/1c-9ci-rwhO1EB7cTknReMxZEzvrdazObXMiVpq9Ov3o/edit?pli=1&tab=t.0
3. https://github.com/AppLoidx/Web-Development-Cheats/blob/master/itmo-university/module%20tests/ModuleTest1.md
4. https://github.com/AppLoidx/Web-Development-Cheats/blob/master/itmo-university/module%20tests/ModuleTest1Questions.md
